In the first three chapters, the author describes the origins  of software engineering 
and makes a point for why this is not necessarily a good approach for all projects.

Software engineering, was devised to tackle very large scale projects, where hardware
was designed-created at the same time as software. While the software-engineering 
approach was (and perhaps is) appropriate for such projects, its application on 
commercial ones is probably not the best approach. 

The alternative *just enough* approach is also discussed; this might work in a small
subset of cases, where the software developed is used by a large audience who does 
not care about the quality of the product and no comparable better-working alternatives
are available. The idea with this approach is to accept poor quality in the name of 
feature richness and fast delivery to market. The problem with this is that not only
is the overall quality poor, but also future iterations on the product will be 
incrementally harder and slower, as the product becomes unnecessarily complex and 
full of defects.

Another interesting point is that there is an imbalance between evolution in technical
terms and in terms of process and people's interaction. So, for instance, we have 
seen incredible improvements in technology, meaning that we have gone from writing
machine language to much more abstract languages, where we do not have to worry 
about hardware control. However, a similar level of evolution cannot be seen in
terms of processes, with software engineering being based on projects of a different
nature to the ones it is applied to and not having significantly evolved.


We should then look for a better metaphor than software engineering. Onto chapter 4.






